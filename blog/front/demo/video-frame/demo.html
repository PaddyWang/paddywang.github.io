<div class="container">
  <div class="content">
    <div>
      <h3>
        先选择一个视频
        <input type="file" accept="video/*" id="file">
      </h3>
      <video id="video" controls></video>
    </div>
    <div>
      <h3>渲染正在播放的视频帧</h3>
      <canvas id="playing-frame" height="500"></canvas>
    </div>
  </div>
  <h3>渲染全部视频帧 <span>(最后一帧可能渲染不全,下一页解决)</span></h3>
  <canvas id="video-frame"></canvas>
</div>

<script>
  const videoEl = document.querySelector('#video');
  const playingFrameEl = document.querySelector('#playing-frame');
  const playCtx = playingFrameEl.getContext('2d');
  // 获取视频容器的宽高 后面所有的容器都是基于视频容器的宽高进行自适应
  const { width: videoContainerW, height: videoContainerH } = videoEl.getBoundingClientRect();
  playingFrameEl.setAttribute('width', videoContainerW);

  let renderWidth = 0;
  let renderHeight = 0;
  let renderX = 0;
  let renderY = 0;

  document.querySelector('#file').addEventListener('change', (event) => {
    const url = URL.createObjectURL(event.target.files[0]);
    videoEl.src = url;
  });

  videoEl.addEventListener('timeupdate', (event) => {
    playCtx.drawImage(videoEl, renderX, renderY, renderWidth, renderHeight);
  });
  /* 渲染视频第一帧 */
  videoEl.requestVideoFrameCallback(() => {
    // 等待视频就绪，获取正确的原始尺寸
    if (videoEl.videoWidth === 0 || videoEl.videoHeight === 0) return;
    
    // 使用 videoWidth/videoHeight（原始解码尺寸）
    const videoWidth = videoEl.videoWidth;
    const videoHeight = videoEl.videoHeight;
    const canvasWidth = videoContainerW;
    const canvasHeight = videoContainerH;
    
    // 计算缩放比例
    const videoAspect = videoWidth / videoHeight;
    const canvasAspect = canvasWidth / canvasHeight;
    
    if (videoAspect > canvasAspect) {
      // 视频比画布更宽
      renderWidth = canvasWidth;
      renderHeight = canvasWidth / videoAspect;
      renderX = 0;
      renderY = (canvasHeight - renderHeight) / 2;
    } else {
      // 视频比画布更高
      renderHeight = canvasHeight;
      renderWidth = canvasHeight * videoAspect;
      renderX = (canvasWidth - renderWidth) / 2;
      renderY = 0;
    }
    
    console.log('视频宽高比:', videoAspect.toFixed(2));
    console.log('画布宽高比:', canvasAspect.toFixed(2));
    console.log('渲染尺寸:', renderWidth, renderHeight);
    console.log('渲染位置:', renderX, renderY);
    
    // 清除画布
    playCtx.clearRect(0, 0, canvasWidth, canvasHeight);
    
    // 绘制视频帧
    playCtx.drawImage(
      videoEl,
      renderX, renderY, renderWidth, renderHeight, // 目标绘制区域
    );
  });

  /* 渲染视频帧 */
  const videoFrameEl = document.querySelector('#video-frame');
  const videoCtx = videoFrameEl.getContext('2d');
  const videoFrameW = videoContainerW * 2 + 20;
  const videoFrameH = 80;
  videoFrameEl.setAttribute('width', videoFrameW);
  videoFrameEl.setAttribute('height', videoFrameH);

  videoEl.addEventListener('loadedmetadata', async () => {
    const videoWidth = videoEl.videoWidth;
    const videoHeight = videoEl.videoHeight;
    const previewWidth = videoWidth * videoFrameH / videoHeight;
    const duration = videoEl.duration;

    // 计算时间轴需要多少帧
    const frameCount = Math.ceil(videoFrameW / previewWidth);
    // 计算帧间隔
    const interval = duration / frameCount;
   
    videoCtx.clearRect(0, 0, videoFrameW, videoFrameH);

    for (let i = 0; i < frameCount; i++) {
      try {
        // 跳转到指定时间点
        videoEl.currentTime = i * interval;
        
        // 等待视频帧可用
        await new Promise((resolve) => {
          const onSeeked = () => {
            videoEl.removeEventListener('seeked', onSeeked);
            
            // 绘制帧到Canvas
            videoCtx.drawImage(videoEl, i * previewWidth, 0, previewWidth, videoFrameH);
            
            resolve(true);
          };
          
          videoEl.addEventListener('seeked', onSeeked);
        });
      } catch (error) {
        console.error('生成帧预览时出错:', error);
      }
    }
    videoEl.currentTime = 0;
  });
</script>

<style>
  .container {
    padding: 20px;
  }
  .content {
    display: flex;
    gap: 20px;
  }
  .content > div {
    flex: 1;
  }
  #video {
    width: 100%;
    height: 500px;
    background-color: black;
  }
  #playing-frame {
    height: 500px;
    background-color: #999;
  }
  #video-frame {
    background-color: #999;
  }
  span {
    font-size: 14px;
    color: #333;
  }
</style>